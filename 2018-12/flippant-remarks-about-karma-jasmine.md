## flippant remarks about Karma-Jasmine in Angular

The details below try to explain these main pointers:

One, [small introduction to Karma-Jasmine](https://github.com/BryanWilhite/nodejs/tree/master/karma-and-jasmine-minimal) outside of Angular reminds us [Karma](https://karma-runner.github.io/latest/index.html) is the “test runner” (from the Angular team) and [Jasmine](https://jasmine.github.io/) is a behavior driven development framework. [Behavior Driven Development](https://en.wikipedia.org/wiki/Behavior-driven_development) is beyond the scope of these remarks apart from the consideration that we might make when use the word _specification_ instead of _test_.

### a Jasmine `*.spec.ts` file is generated by the Angular CLI by default

Unless the `--spec=false` option is explicitly used, `ng generate component` [[docs](https://angular.io/cli/generate#component)] will auto-generate a Jasmine spec file like this:

```typescript
import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { MyComponent } from './my.component';

describe('MyComponent', () => {
  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ MyComponent ]
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
```

One way to easily be confused by the Karma-Jasmine combo is not really, really understanding that `async`, `ComponentFixture` and `TestBed` do _not_ come from Jasmine—we must depend on the Angular team to [tell us](https://angular.io/guide/testing) about these things. One of these things is the use of `async` with `beforeEach`. A [StackOverflow.com answer](https://stackoverflow.com/a/40127164/22944) asserts that `async` (from the Angular team) replaces the use of `done()` which is native to Jasmine [[docs](https://jasmine.github.io/tutorials/async)]. `ComponentFixture` and `TestBed` are covered reasonably well by the Angular team [[docs](https://angular.io/guide/testing#component-test-basics)].

### using `NO_ERRORS_SCHEMA`

The auto-generated test above might be for a component with an HTML file like this:

```html
<div class="css-class">
    <app-my-child [prop1]="foo.bar" [prop2]="fuBar.prop3"></app-my-child>
</div>
```

By default, the test will likely throw a very verbose error like this:

```console
Failed: Template parse errors:
'app-my-child' is not a known element:
1. If 'app-my-child' is an Angular component, then verify that it is part of this module.
…
```

We need to tell our `TestBed` to ignore “custom” elements like `app-my-child`:

```typescript
import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { MyComponent } from './my.component';

describe(MyComponent.name, () => {
  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ MyComponent ],
      schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
```

For more detail on `NO_ERRORS_SCHEMA`, see the [docs](https://angular.io/guide/testing#no_errors_schema). Also note that we can cut down on the use of magic strings by using `MyComponent.name` which is convenience from the Angular team.

### the mysterious `[object ErrorEvent] thrown` error

The `NO_ERRORS_SCHEMA` remedy might be followed by another, more mysterious Jasmine error:

```console
[object ErrorEvent] thrown
```

What is happening in our HTML example above is the null value of `foo` in the binding `foo.bar` and the null value of `fuBar` in the binding `fuBar.prop3`. The typescript of a component backing these bindings might look like this:

```typescript
import { Component, OnInit } from '@angular/core';
import { FooService } from '../../services/foo.service';

@Component({
  selector: 'app-my-widget',
  templateUrl: './my.component.html',
  styleUrls: ['./my.component.css']
})
export class ContextPanelComponent implements OnInit {
  @Input
  fuBar: {};

  constructor(public foo: FooService) { }

  ngOnInit() {
    foo.loadBar();
  }
}
```

We see that `fuBar` is an `@Input` property and `foo` is injected as a service. To address these members of the component, we update our Jasmine spec:

```typescript
import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { FooService } from '../../services/foo.service';
import { MyComponent } from './my.component';

describe(MyComponent.name, () => {
  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ MyComponent ],
      providers: [ { provide: FooService, useValue: null } ],
      schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;

    component.fuBar = { prop3: null };

    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
```

This updated spec should still throw the same cryptic error, `[object ErrorEvent] thrown`, because, while we _did_ address `fuBar`, we did _not_ provide a value for `FooService`. It is often useful to provide a null value for a service to show that the service might not be necessary and should be removed from the component. Let’s flippantly provide a value for `FooService`:

```typescript
import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { FooService } from '../../services/foo.service';
import { MyComponent } from './my.component';

describe(MyComponent.name, () => {
  const fooService = { bar: null };

  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ MyComponent ],
      providers: [ { provide: FooService, useValue: fooService } ],
      schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;

    component.fuBar = { prop3: null };

    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});
```

The spec should now be valid. Now we can actually specify an interesting behavior (write an actual test). Let’s test whether `foo.loadBar()` was called by _spying_ on it. We can replace `fooService` with the value of `createSpyObj()` [[docs](https://jasmine.github.io/api/2.8/jasmine.html#.createSpyObj)]:

```typescript
import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { FooService } from '../../services/foo.service';
import { MyComponent } from './my.component';

describe(MyComponent.name, () => {
  const loadBarMethodName = 'loadBar';
  const fooService = jasmine.createSpyObj(FooService.Name, [loadBarMethodName]);
  fooService.bar = null;

  let component: MyComponent;
  let fixture: ComponentFixture<MyComponent>;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ MyComponent ],
      providers: [ { provide: FooService, useValue: fooService } ],
      schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;

    fooService[loadBarMethodName].calls.reset();
    component.fuBar = { prop3: null };

    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });

  it(`should call ${loadBarMethodName}`, () => {
    expect(fooService[loadBarMethodName].calls.count()).toBe(1, 'The expected number of service calls is not here.');
  });

});
```

In typescript, `fooService` will be of type `any`. So, when we see the `calls` object (or “namespace”) hanging off it, we might need to go to [the Jasmine documentation](https://jasmine.github.io/api/2.8/Spy_calls.html) to see what is going on.

### use of the “Elvis operator” in the HTML

Had our HTML been like this:

```html
<div class="css-class">
    <app-my-child [prop1]="foo?.bar" [prop2]="fuBar?.prop3"></app-my-child>
</div>
```

We could have avoided writing these lines of spec code:

```typescript
fooService.bar = null;
…
component.fuBar = { prop3: null };
```

The use the Elvis operator has some issues with async in bindings, see “[The Angry Angular AsyncPipe & The Evil Elvis Operator](https://hackernoon.com/the-angry-angular-asyncpipe-the-evil-elvis-operator-89293e37e04d)” by Vitaliy Isikov.

### the ‘right’ way to initialize `@Input` values

In my example above, you see me explicitly setting the value of `fuBar`. To test whether `@Input` is working (which is kind of like testing something that belongs to the Angular team) we can set up a mock component to host `MyComponent`. This is detailed in “[Testing Angular components with @Input()](https://medium.com/@AikoPath/testing-angular-components-with-input-3bd6c07cfaf6)” by Aiko Klostermann of Thoughtworks.

### using formal mocks

I am very, very certain that Angular team does not recommend constructing a mock inline as we have seen above:

```typescript
const loadBarMethodName = 'loadBar';
const fooService = jasmine.createSpyObj(FooService.Name, [loadBarMethodName]);
fooService.bar = null;
```

I find this helpful when I am _not_ repeating myself in multiple `*.spec.ts` files and it is less intimidating to first-time Jasmine writers.

### commenting out `fixture.detectChanges()`

Commenting out `fixture.detectChanges()` in specs might prevent the spec from throwing errors. This is a surefire way to consider that any failures with this line enabled are due to binding issues.

### the auto-generated tests for services look different

When a test for a service is generated (with `ng generate service` [[docs](https://angular.io/cli/generate#service)]) the main difference is the use of `inject` (also from the Angular team):

```typescript
it('should be created', inject([MyService], (service: MyService) => {
  expect(service).toBeTruthy();
}));
```

### the `NullInjectorError: No provider for HttpClient!` error

When the `NullInjectorError: No provider for HttpClient!` error is thrown, the knee-jerk response is to add `imports: [HttpClientModule]` to the `TestBed`. The better response is to import `HttpClientTestingModule` (with `HttpTestingController`) instead. This is detailed in “[Testing with the Angular HttpClient API](https://medium.com/netscape/testing-with-the-angular-httpclient-api-648203820712)” by Ciro Nunes.

There is a similar Karma-Jasmine error that should lead us to importing `RouterTestingModule` as described in “[Using Jasmine framework to test Angular Router](https://medium.com/burak-tasci/using-jasmine-framework-to-test-angular-router-b568a232efed)” by Burak Tasci.

@[BryanWilhite](http://twitter.com/BryanWilhite)