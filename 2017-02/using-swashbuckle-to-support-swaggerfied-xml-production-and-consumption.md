# Using Swashbuckle to Support Swaggerfied XML Production and Consumption

Every ASP.NET NuGet package that I have used before [Swashbuckle](http://www.nuget.org/packages/Swashbuckle/5.5.3) spoiled me with just working out of the box and/or having decent documentation. When I used [ELMAH](https://www.nuget.org/packages/elmah/) (before [Application Insights](https://azure.microsoft.com/en-us/services/application-insights/)), I _felt_ that it just worked. [Autofac](https://www.nuget.org/packages/Autofac/) gives me that same feeling as well (in spite of some [drama](http://songhayblog.azurewebsites.net/entry/my-autofac-packages-drama)). My point is that Swashbuckle really stands out due to my particular approach to the technology.

My approach (due to the demands of my day job) is the need to consume/produce XML. I am deliberately using consume/produce, by the way, to align with produces/consumes of [the Swagger Specification](http://swagger.io/specification/). So let’s take a look at the default Swagger UI for an XML endpoint auto-generated by version 5.5.3 of Swashbuckle:

<div style="text-align:center">

[![Swashbuckle Swagger UI is JSON-centric by default](https://farm1.staticflickr.com/645/31941217903_4d0bf088c2_z_d.jpg "Swashbuckle Swagger UI is JSON-centric by default")](https://www.flickr.com/photos/wilhite/31941217903/in/dateposted-public/)

</div>

It took me awhile to notice the obvious: Swashbuckle is biased toward JSON. This makes perfect sense until we go back to XML. Here is the ASP.NET Web API controller method that Swashbuckle is working with:

``` c#
/// <summary>
/// Consumes the XML.
/// </summary>
/// <param name="xmlInput">The XML input.</param>
/// <returns></returns>
/// <remarks>
/// This endpoint cannot catch malformed XML errors for the logging system.
/// This endpoint was intended for use in Swagger,
/// using the same critical code that the production endpoint uses.
/// </remarks>
[HttpPost]
[Route("xml-endpoint")]
public IHttpActionResult ConsumeXml([FromBody]XElement xmlInput)
{
    return this.Ok<XElement>(xmlInput.ToResponseDocument());
}

```

When I mention that `ToResponseDocument()` in the method body above is just an some custom extension method that I wrote, we can disregard the method body. Swashbuckle is pretty much doing that as well. In order to get Swashbuckle to tell Swagger to consume/produce XML _exclusively_, we need to add custom method attributes and respective classes implementing `IOperationFilter` [in Swashbuckle.Core](https://github.com/domaindrivendev/Swashbuckle/blob/master/Swashbuckle.Core/Swagger/IOperationFilter.cs) mediated by entries in `SwaggerConfig.cs`. This is what our controller method looks like with these custom attributes:

``` c#
/// <summary>
/// Consumes the XML.
/// </summary>
/// <param name="xmlInput">The XML input.</param>
/// <returns></returns>
/// <remarks>
/// This endpoint cannot catch malformed XML errors for the logging system.
/// This endpoint was intended for use in Swagger,
/// using the same critical code that the production endpoint uses.
/// </remarks>
[HttpPost]
[Route("xml-endpoint")]
[ConsumptionContentType(mimeType: "application/xml", Exclusive = true)]
[ProductionContentType(mimeType: "application/xml", Exclusive = true)]
public IHttpActionResult ConsumeXml([FromBody]XElement xmlInput)
{
    return this.Ok<XElement>(xmlInput.ToResponseDocument());
}

```

With these attributes (and their backing `IOperationFilter` classes), we can now see Swashbuckle generating improved Swagger:

<div style="text-align:center">

[![Swashbuckle Swagger UI with basic XML customization](https://farm1.staticflickr.com/584/32714653736_330d5a60cd_z_d.jpg)](https://www.flickr.com/photos/wilhite/32714653736/in/dateposted-public/)

</div>

To make this happen, we need to pull our custom attributes by querying [`ApiDescription`](https://msdn.microsoft.com/en-us/library/system.web.http.description.apidescription(v=vs.118).aspx) so we can use attribute data to edit an instance of Swashbuckle’s `Operation` class (which I strongly suspect has been replaced by the `SwaggerDocument` class [in the current build](https://github.com/domaindrivendev/Swashbuckle/blob/2ed189b041e0e7849ec59a2fa2c0078e540a8359/Swashbuckle.Core/Swagger/SwaggerDocument.cs) as of this writing) used to generate standard Swagger. My `*OperationFilter` classes handle this work. [My GitHub Gist](https://gist.github.com/BryanWilhite/1a0e8c14a5002995aa5eb7984bfa5cd0) shows these classes along with their respective custom attributes.

Once all of these classes are in place and the method attributes are adorning, we can add these lines to that `GlobalConfiguration.Configuration.EnableSwagger` lambda expression in `SwaggerConfig.cs` jam-packed with comments:

``` C#
// Similar to Schema filters, Swashbuckle also supports Operation and Document filters:
//
// Post-modify Operation descriptions once they've been generated by wiring up one or more
// Operation filters.
//
//c.OperationFilter<AddDefaultResponse>();
//
// Set filter to apply Custom Content Types to operations
c.OperationFilter<ConsumptionContentTypeOperationFilter>();
c.OperationFilter<ProductionContentTypeOperationFilter>();
```

So we can see that Swashbuckle Configuration loads the `*OperationFilter` classes which query for the custom attributes that modify how Swashbuckle will generate Swagger. It really, really looks like this pattern is going to change in Swashbuckle 6.x which is currently in beta as of this writing.

I also notice that all of this work has no control over the “Example Value” XML shown in the Swagger UI. I think this is controlled by [the Swagger Definitions Object](http://swagger.io/specification/#definitionsObject). Assuming that a newer version of Swashbuckle will _not_ get this working out of the box _for XML_, I will have to come back to this later.